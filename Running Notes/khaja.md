Running Notes 
--------------
# Python
* Lamda service: turn off the computer, when you log out
* Serverless Service: no need of servers
* code is run as function
## ctl+H
  ### Editors
  * Find and replace
  ###  Browsers
  * Getting history
# Multi-Cloud
* scale_up/ scale_down --> vertical scalling
* scale_in/scale_out --> horizontal scalling
* `htop`
* ` stress-ng --cpu 8 --cpu-method all --timeout 60 --metrics-brief`


## AWS
* AWS don't stop  we have to stop and do scale_up/ scale_down
  * ### Scaling Policies
    * Simple/Step scaling
    * Target Tracking policy
    * Predictive scaling
      * it requires atleast two days of monitering
* `target group == auto scaling group`
* In interviews we have to say about `zero downtime deployment` policy
### Cloudformation
* In cloudformation stack is necessary
* Stack is like resource group in Azure
* 


## Azure
* Compute Gallery
* Azure stop and do scale_up/ scale_down
* Virtual machine scale sets = Auroscaling groups
* for predictive scaling it requiers atlaeast 2 days of time
* `Application health monitering` == `Amazon Cloud Watch`

### Azure Resource Manager (ARM) templates
* ref(https://learn.microsoft.com/en-us/azure/templates/)
* variables = local.tf(terraform)
* parameters = user inputs
* Content versionn is like tags which you  have to pass
* resource provider = for every service we have  different providers
* resource name = compute, network










* #### fixed scaling
  * give no of machines and those no of machines are maintained
* `Target Group` = `backend target`
* `rules` = `listeners`
* `health checks` == `health probes`
* #### load balacer
  * paths
  * headers
  * domains
* sticky sessions
  * these are in both applicaion lb and network lb
* `backend == virtual machine scale sets`
# terraform
* In interviews you have to say that I did terrascan and looking for any vulnerability issues.
## Terraform cloud
* when ever you are using git use tags section for terraform
* terrascan 
* terraform unit tests(It is not that much importance)
* terraform cloud
# Docker
* in `docker container run -d -P --name akhil ak:1`
  * In this docker is the command line tool
# K8s 19/10/2024 Morning
* Lables can be applied to following objects of k8s for querrying
* Objects of k8s
  * Nodes
  * pods
  * replicasets
  * deployments
  * Daemonsets
  * Statefulsets
## Daemonset
* Kubelet is nothing but Daemonset
* Kubeproxy is nothing but Daemonset
* For collecting logs from nodes Daemonsets are necessary
* Daemonsets is nothing but Agent kind of setup
* Daemonsets are helpfull in rollbacks and rollingupdates
## Statefulsets
* Difference between stateless and stateful
* stateless is nothing but applicaitons which store data generated by it on other data bases pod or data bases (frontend applications)
* stateful applications are nothing but store the data which is generated by it or other applications data(frontend applications)
* Generally statefulsets sets are nothing but pods with database applications like postgres, mysql etc.,
## Connecting to k8s cluster
  1. kubectl 
  2. client libraries(python, java)
* By using REST-API above two will connect with k8s
## kubectl [command] [TYPE] [NAME] [flags]
###  Commands
* [refer_here](https://kubernetes.io/docs/reference/kubectl/)
* Only 4 types of commands in k8s
   1. create
   2. apply
   3. upgrade
   4. delete
   5. get
### TYPES
* kubectl api-resources
### NAMES
* Names that you give to resources which you are going to created 
### flags
* [refer-here](https://kubernetes.io/docs/reference/kubectl/generated/kubectl/) for flags
# 19/10/2024 K8s Evening 
* yaml and json is data representation in the format of key,value pair
* This is not scripting language but it is a data representation
* Files are of 3 types
  1. Human Readble
     1. Understandable by humans
  2. Machine Redble
     1. Understandable by machines
  3. Configaration files
     1. Understandable by both Humans and Machines
* Write the manifest based on server api version to know it `kubectl version`
## Commands for kubectl
```sh 
kubectl get pods <pod-name> -o yaml
kubectl get pods --help
kubectl get po -w # 'w' means watch
kubectl get pods --show-labels
```
## CrashsloopBackoff
* k8s tries to restart the container when it goes to exited state
* If it continously failing then we see CrashsloopBackoff error.
## Init containers
* We have web application and db appliction
* init containers are created in application pod 
  * Don't start application container untill db pod is created
  * For the checking purpose we use init containers
  * Init containers goes to exited stated when db pod got start
* 